## Singleton
**Singleton** 
یک الگوی  تولیدی یا همون به قول زبان فارسی خلاقانه است که به شما امکان می دهد اطمینان حاصل کنید که یک کلاس فقط یک نمونه یا همون آبجکت داره ، و دسترسی همگانی به این آبجکت داده میشه

###  چرا سینگلتون ؟ 😟 

الگوی سینگلتون دو مشکل اصلی را همزمان حل میکند اما با هزینه نقض 
Single Responsibility Principle

اول از همه از هر کلاس یک موجودیت یا همون آبجکت خودمون رو تولید میکنه یعنی یه جورایی به ما اطمینان میده که اقا این کلاس شما فقط و فقط یک آبجکت ازش ساخته میشه غمت نباشه حالا چرا غممون نباشه ؟؟
رایج ترین دلیل این امر کنترل دسترسی به برخی از منابع مشترک است - به عنوان مثال، یک پایگاه داده یا یک فایل.

حالا چ طور ممکنه بزارین بازش کنیم 
نحوه کار به این صورت است: تصور کنید که یک شی ایجاد کرده اید، اما پس از مدتی تصمیم به ایجاد یک شی جدید دارید. به جای دریافت یک شیء تازه، شیئی را که قبلا ایجاد کرده اید دریافت خواهید کرد.

توجه داشته باشید که اجرای این رفتار با یک سازنده غیرممکن است زیرا یک فراخوان سازنده همیشه باید یک شی جدید را با طراحی   برگرداند اروم اروم بهش میرسیم
![مشتریان حتی ممکن است متوجه نشوند که همیشه با یک شی کار می کنند.](https://github.com/ftg-iran/didp-persian/raw/main/4-Catalog%20Of%20Design%20Patterns/images/content/singleton/singleton-comic-1-en.png)


یک نقطه دسترسی گلوبال به آن ابجکت ارائه میده . متغیرهای گلوبال را که شما برای ذخیره برخی از آبجکت ضروری استفاده کردید، به خاطر دارید؟ اگرچه آنها بسیار مفید هستند، اما بسیار 
ناامن هستند زیرا هر کدی می تواند محتویات آن متغیرها را بازنویسی کند و برنامه را خراب کند.
یعنی در کل میخوایم بگمی که اقا هر کسی بهش دسترسی داره 

نتیجه کلی که میتونیم بگیریم اینه که 
**singleton** جناب
به ما کمک میکنه و اجازه میده که از هر جای برنامه که یه شی هست ازش استفاده کنیم از طرفی جلوی عوض شدن و تغییر داخل یک سری از آبجکت ها رو میگیره یعنی به قول کتاب ، آن آبجکت را از بازنویسی شدن توسط کدهای دیگر نیز محافظت می کند

###   خب راه حل چیه ؟😃
  : تمام پیاده سازی های این الگو دو گام مشترک دارن 
   
   
اول از همه سازنده پیش فرض را خصوصی کنید تا دیگر اشیا از عملگر جدید با کلاس Singleton 
.استفاده نکنند

ئوم از همه این که یک  روش استتیک  ایجاد کنید که به عنوان سازنده عمل بکنه . تحت این شرایط ، این روش سازنده پرایوت را برای ایجاد یک شی فراخوانی می کند و آن را در یک فیلد ثابت ذخیره می کند. همه فراخوانی های بعدی به این متد، ـبجکت ذخیره شده را برمی گرداند.

 ### در دنیای واقعی singleton  🚗  
 دولت نمونه ای عالی از الگوی سینگلتون است. یک کشور می تواند تنها یک دولت رسمی داشته باشه صرف نظر از هویت شخصی افراد تشکیل دهنده دولت،
 مثلا : 
 «دولت ایران» یک نقطه دسترسی گلوبال است که گروه افراد مسئول را مشخص می کند.
 **

***پی نوشت***
منظور از جمله بالا اینه که دولت ایران یا همون الگوی سینگلتون ما حواسش به آبجکت ها هست و هر آبجکت رو مسئول  کار خودش میکنه 


![](https://github.com/ftg-iran/didp-persian/raw/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/singleton/structure-en-indexed.png)
.
***توضیحی کوتاه و مختصر توسط خودم به زبان فارسی تو ترجمه خیلی گنگ ترجمه میشه*** 
کلاس سینگلتون عزیز ما با متود یا همون تابع داخلی خودش به نام 
getInstance 
میاد همون آبجکتی که داره رو بر میگردونه یعنی اگر ازش ساخته نشده بود یه دونه میسازه بر میگردونه ولی بعد اون اگر ساخته شده بود دیگه نمیسازه همون قبلی رو که داخل متغیری ه به نام 
instance 
دخیره کرده بود بر میگردونه 

### قطعه کد نمونه#️⃣  
در این مثال، کلاس اتصال پایگاه داده به عنوان
 Singleton
 عمل می کند. این کلاس سازنده عمومی ندارد، بنابراین تنها راه برای دریافت شیء آن فراخوانی متد getInstance است. این متد اولین آبجکت ایجاد شده را کش می کند و در تمام فراخوانی های بعدی آن را برمی گرداند.

    // The Database class defines the `getInstance` method that lets
    // clients access the same instance of a database connection
    // throughout the program.
        class Database is
        // The field for storing the singleton instance should be
        // declared static.
        private static field instance: Database

    // The singleton's constructor should always be private to
    // prevent direct construction calls with the `new`
    // operator.
    private constructor Database() is
        // Some initialization code, such as the actual
        // connection to a database server.
        // ...
    // The static method that controls access to the singleton
    // instance.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
            // Ensure that the instance hasn't yet been
            // initialized by another thread while this one
            // has been waiting for the lock's release.
            if (Database.instance == null) then
                Database.instance = new Database()
        return Database.instance

    // Finally, any singleton should define some business logic
    // which can be executed on its instance.
    public method query(sql) is
        // For instance, all database queries of an app go
        // through this method. Therefore, you can place
        // throttling or caching logic here.
        // ...

    class Application is
    method main() is
        Database foo = Database.getInstance()
        foo.query("SELECT ...")
        // ...
        Database bar = Database.getInstance()
        bar.query("SELECT ...")
        // The variable `bar` will contain the same object as
        // the variable `foo

### 💡  فابلیت اجرا 
از الگوی
 Singleton
  زمانی استفاده کنید که یک کلاس در برنامه شما باید فقط یک آبجکت در دسترس همه کلاینت ها باشد. به عنوان مثال، یک شی پایگاه داده تک  که توسط بخش های مختلف برنامه به اشتراک گذاشته شده است.
  ✨ الگوی 
  Singleton 
  تمام روش های  دیگر برای ایجاد اشیاء یک کلاس را غیرفعال می کند، به جز روش ایجاد خاص. این متد یا یک شی جدید ایجاد می کند یا اگر قبلاً ایجاد شده باشد، یک آبجکت را برمی گرداند.
  ✨ برخلاف متغیرهای سراسری الگوی
  Singleton
   تضمین می‌کند که فقط یک نمونه از یک کلاس وجود دارد. هیچ چیز، به جز خود کلاس Singleton،
    نمی تواند جایگزین نمونه ذخیره شده شود.
    
 ### 📋  چ طوری پیاده سازی کنیم حالا ؟
 
یک فیلد استاتیک خصوصی به کلاس برای ذخیره نمونه 
**singleton**
 اضافه کنید.

یک روش ایجاد استاتیک عمومی برای به دست آوردن نمونه سینگلتون مشخص کنید.

در روش استاتیک، "آغاز اولیه تنبل" را پیاده سازی کنید. باید در اولین فراخوانی خود یک شی جدید ایجاد کرده و آن را در فیلد استاتیک قرار دهد. متد همیشه باید آن نمونه را در تمام فراخوانی های بعدی برگرداند.

***پی نوشت*** 
*منظور از اغاز اولیه تنبل 
lazy intalization
هست که خب چه کنیم ترجمش اینه اما یه لینک برای مطالعه اش میزارم* 
[بزن بریم ](https://roocket.ir/articles/lazy-initialization-pattern)


سازنده کلاس را خصوصی کنید. متد استاتیک کلاس همچنان قادر خواهد بود سازنده را فراخوانی کند، اما سایر اشیاء را نه.

روی کد کلاینت بروید و همه ارتباط های مستقیم سازنده singleton را با فراخوانی‌های روش  با  با ایجاد استاتیک آن جایگزین کنید.

### ⚖️    خب حالا که چی ؟استفاده کنیم یا نه ؟ مرگ یا زندگی ؟

✔️ می توانید مطمئن باشید که یک کلاس فقط یک نمونه دارد.
✔️ شما یک نقطه دسترسی گلوبال به آن نمونه بدست می آورید.

✔️ شی 
singleton
 فقط زمانی مقداردهی اولیه می شود که برای اولین بار درخواست شود.

✖️ the Single Responsibility
 را نقش می کند. این الگو در آن زمان دو مشکل را حل می کند .

✖️ الگوی 
Singleton 
می تواند طراحی بد را پنهان کند، برای مثال، زمانی که اجزای برنامه اطلاعات زیادی درباره یکدیگر دارند.

✖️ این الگو نیاز به درمان خاصی در یک محیط چند رشته ای دارد به طوری که نخ های متعدد چندین بار یک شی تک را ایجاد نکنند.

✖️ ممکن است تست نویسی  واحد کد کلاینت 
Singleton
 دشوار باشد زیرا بسیاری از چارچوب‌های آزمایشی هنگام تولید ابجکت های ساختگی به وراثت متکی هستند. از آنجایی که سازنده کلاس 
 singleton
  خصوصی است و غلبه بر روش‌های استاتیک در بیشتر زبان‌ها غیرممکن است، باید راه  بیاندیشید
 یا فقط تست ها را ننویسید. یا از الگوی 
  Singleton
   استفاده نکنید
   ### 🔄  فضولی تو کار بقیه الگو ها 
   
   یک کلاس
    Facade 
    اغلب می تواند به یک 
    Singleton
     تبدیل شود زیرا یک شی نما در بیشتر موارد کافی است.

Flyweight
 شبیه
  Singleton
   خواهد بود اگر بتوانید به نحوی تمام حالات مشترک اشیاء را به یک جسم با وزن پرواز کاهش دهید. اما دو تفاوت اساسی بین این الگوها وجود دارد:

فقط یک نمونه 
Singleton 
باید وجود داشته باشد
، در حالی که یک کلاس
 Flyweight
  می تواند چندین نمونه با حالت های ذاتی مختلف داشته باشد.

شی 
Singleton 
می تواند قابل تغییر باشد. اجسام با 
flyweight
 تغییرناپذیر هستند.

کارخانه‌های انتزاعی، سازندگان و نمونه‌های اولیه همگی می‌توانند به‌عنوان 
Singletons 
پیاده‌سازی شوند.
