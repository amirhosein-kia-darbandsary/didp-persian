## آداپتور
### هم چنین به عنوان دسته بندی کننده گفته میشود 


 
## 😟 مشکل 

تصور کنید در حال ساخت یک برنامه تحت نظارت بر یک بازار سهام هستید این برنامه داده های سهام رو از چندین منابع مختلف در یافت میکند و در فالب 

**XML**

دانلود میکند سپس نمودار ها رو برای کاربر نشان میدهد 

حالا تصمیم میگیرید که که با ادغام بک کتابخانه خارجی رو برای ارتقا تحلیل های بهتر اضافه کنید 

ولی مشکل اینجاست که این کتابخونه فقط و تنها با فایل های 

**Json**

کار میکند و  دیتای شما بر خلاف چیزی است که در اختیار دارید 

![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/problem-en.png)
=
شما نمی توانید از کتابخانه تجزیه و تحلیل «همانطور که هست» استفاده کنید، زیرا انتظار دارد داده ها در قالبی ناسازگار با برنامه شما باشد

شما میتوانید که کتابخانه رو برای استفاده های خودتان تغییر دهید اما ممکن است که با مشکل رو در رو شوید یا به سورس کد های کتابخانه دسترسی نداشته باشید .


## 😃 راه حل 

شما میتوانید یک اداپتور ایجاد کنید این میتواند شیی باشد که میتواند اینترفیس یک شی را به شی دیگر تغییر دهد 


یعنی یک اداپتور یکی از اشباه رو مخفی میکند و پیچیدگی کار را نشان نمیدهد برای مثال شما میتوانید 
یک شیی را که متر و کیلومتر را اندازه میگیرد به واسطه یک آداپتور به مایل و فیت تبدیل کنید


آداپتورها نه تنها می‌توانند داده‌ها را به فرمت‌های مختلف تبدیل کنند، بلکه می‌توانند به اشیاء با رابط‌های مختلف کمک کنند در اینجا نحوه عملکرد آن آمده است

- اداپتور یک رابطه سازگار با شی پیدا میکند 
- با استفاده از این رابطه شی موجود میتواند راحت متود های داخل اداپتور را فراخوانی کند 
- پس از دریافت فراخوانی  آداپتور درخواست را به شی دوم ارسال می کند، اما در قالب و ترتیبی که شی دوم انتظار دارد.


 ***بعضی اوفات میتوان که اداپتوری ساخت دو طرفه باشد***


![Image](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/solution-en.png)

---

## 🚗در دنیای وافعی


هنگامی که برای اولین بار از ایالات متحده به اروپا سفر می کنید، ممکن است هنگام تلاش برای شارژ لپ تاپ خود غافلگیر شوید. استانداردهای دوشاخه و پریز برق در کشورهای مختلف متفاوت است.

![Image](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/content/adapter/adapter-comic-1-en.png)

A suitcase before and after a trip abroad.

به همین دلیل است که دوشاخه ایالات متحده شما با سوکت آلمانی مناسب نیست. مشکل را می توان با استفاده از یک آداپتور برقی که دارای سوکت آمریکایی و دوشاخه سبک اروپایی است حل کرد.
یا به صورت کلی منظور یک تبدیل دو شاخه امریکایی به پریز برق های المانی است 

## 🚧 ساختار

#### شی مبدل 

این پیاده سازی از اصل ترکیب شی استفاده می کند: آداپتور رابط یک شی را پیاده سازی می کند و شی دیگر را  wrrpa میکند . می توان آن را در تمام زبان های برنامه نویسی رایج پیاده سازی کرد.


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/structure-object-adapter-indexed.png)


- کلاینت
کلاسی است که شامل منطق تجاری موجود برنامه است 

- رابط مشتری پروتکلی را توصیف می کند که سایر کلاس ها باید از آن پیروی کنند تا بتوانند با کد مشتری همکاری کنن

- Adapter 
کلاسی است که می تواند هم با سرویس گیرنده و هم با سرویس کار کند: کلاینت  را پیاده سازی می کند، در حالی که شی سرویس را بسته بندی می کند. آداپتورفراخوانی ها  را از طریق رابط آداپتور از مشتری دریافت می‌کند و آنها را به فراخوانی هایی  با شیء بسته‌بندی شده سرویس در قالبی که قابل درک باشد تبدیل  می‌کند.

- کد کلاینت  تا زمانی که از طریق رابط کلاینت  با آداپتر کار می کند با کلاس آداپتور بتن همراه نمی شود. به لطف این، می توانید انواع جدیدی از آداپتورها را بدون شکستن کد مشتری موجود وارد برنامه کنید. این می تواند زمانی مفید باشد که رابط کلاس سرویس تغییر کند یا جایگزین شود: شما فقط می توانید یک کلاس آداپتور جدید بدون تغییر کد کلاینت  ایجاد کنید.



## کلاس آداپتور 

این پیاده سازی از وراثت  یا همون شی گرایی استفاده می کند: آداپتور رابط ها را از هر دو شی به طور همزمان به ارث می برد. توجه داشته باشید که این رویکرد فقط در زبان‌های برنامه‌نویسی که از وراثت چندگانه پشتیبانی می‌کنند، مانند C++ قابل پیاده‌سازی است.


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/structure-class-adapter-indexed.png)



#️⃣ شبه کد 
این نمونه از الگوی آداپتور مبتنی بر تداخل    بین میخ های مربعی و سوراخ های گرد است.
یه حورایی منظور اینه که ما مثلا میخوایم میخ مربعی رو داخل دایره ای استفاده کنیم 
اما باید یک مبدل داشته باشید 


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/example.png)


آداپتور وانمود می کند که یک میخ گرد است، با شعاع برابر با نیمی از قطر مربع (به عبارت دیگر، شعاع کوچکترین دایره ای که می تواند میخ مربع را در خود جای دهد).

```c++
// Say you have two classes with compatible interfaces:
// RoundHole and RoundPeg.
class RoundHole is
    constructor RoundHole(radius) { ... }

    method getRadius() is
        // Return the radius of the hole.

    method fits(peg: RoundPeg) is  
        return this.getRadius() >= peg.getRadius()

class RoundPeg is
    constructor RoundPeg(radius) { ... }

    method getRadius() is
        // Return the radius of the peg.


// But there's an incompatible class: SquarePeg.
class SquarePeg is
    constructor SquarePeg(width) { ... }

    method getWidth() is
        // Return the square peg width.


// An adapter class lets you fit square pegs into round holes.
// It extends the RoundPeg class to let the adapter objects act
// as round pegs.
class SquarePegAdapter extends RoundPeg is
    // In reality, the adapter contains an instance of the
    // SquarePeg class.
    private field peg: SquarePeg

    constructor SquarePegAdapter(peg: SquarePeg) is
        this.peg = peg
        
    method getRadius() is
        // radius that could fit the square peg that the adapter
        // The adapter pretends that it's a round peg with a
        // actually wraps.
        return peg.getWidth() * Math.sqrt(2) / 2
// Somewhere in client code.
hole = new RoundHole(5)
rpeg = new RoundPeg(5)
hole.fits(rpeg) // true

small_sqpeg = new SquarePeg(5)
large_sqpeg = new SquarePeg(10)
hole.fits(small_sqpeg) // this won't compile (incompatible types)

small_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)
large_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)
hole.fits(small_sqpeg_adapter) // true
hole.fits(large_sqpeg_adapter) // false
```

## 💡 قابلیت کاربرد

- [ ] وقتی می خواهید از کلاس موجود استفاده کنید، از کلاس Adapter استفاده کنید، اما رابط آن با بقیه کد شما سازگار نیست.

✨الگوی Adapter به شما امکان می دهد یک کلاس  میانی ایجاد کنید که به عنوان مبدل  بین کد شما و یک کلاس قدیمی، یک کلاس خارجی  یا هر کلاس دیگری با رابط کاربری عجیب و غریب عمل می کند.

- [ ] وقتی می خواهید دوباره استفاده کنید از الگو استفاده 
کنید

- [ ] وقتی می خواهید از کلاس موجود استفاده کنید، از کلاس Adapter استفاده کنید، اما رابط آن با بقیه کد شما سازگار نیست.

✨الگوی Adapter به شما امکان می دهد یک کلاس  میانی ایجاد کنید که به عنوان مبدل  بین کد شما و یک کلاس قدیمی، یک کلاس خارجی  یا هر کلاس دیگری با رابط کاربری عجیب و غریب عمل می کند.

- [ ] وقتی می خواهید دوباره استفاده کنید از الگو استفاده کنید


## ⚖️ سود ها و ضرر ها 

✔️ اصل**single responsibilty**. می توانید رابط یا کد تبدیل داده را از منطق  اصلی برنامه جدا کنید.

✔️ اصل باز/بسته. شما می توانید انواع جدیدی از آداپتورها را بدون شکستن کد کلاینت  موجود به برنامه معرفی کنید، به شرطی که از طریق رابط کلاینت  با آداپتورها کار کنند.

✖️ پیچیدگی کلی کد افزایش می یابد زیرا باید مجموعه ای از رابط ها و کلاس های جدید را معرفی کنید. گاهی اوقات ساده تر است که کلاس سرویس را طوری تغییر دهید که با بقیه کد شما مطابقت داشته باشد.


## 🔄 ارتباط با بقیه الگو ها


- لگوی پل معمولاً از قبل طراحی می شود و به شما امکان می دهد بخش هایی از یک برنامه را مستقل از یکدیگر توسعه دهید. از سوی دیگر، Adapter معمولاً با یک برنامه موجود استفاده می شود تا برخی از کلاس های ناسازگار را به خوبی با هم کار کنند.

- آداپتور رابط یک شی موجود را تغییر می دهد، در حالی که Decorator یک شی را بدون تغییر رابط آن بهبود می بخشد. علاوه بر این، Decorator از ترکیب بازگشتی پشتیبانی می کند، که با استفاده از آداپتور امکان پذیر نیست.


- آداپتور یک رابط متفاوت برای شی wrrap  شده ارائه می دهد، Proxy با همان رابط و Decorator یک رابط پیشرفته برای آن ارائه می دهد.
- 
فیسادها )(facade ) یک رابط جدید برای اشیاء موجود تعریف -می کند، در حالی که Adapter سعی می کند رابط موجود را قابل استفاده کند. آداپتور معمولاً فقط یک شی را می پیچد، در حالی که Facade با یک زیر سیستم کامل از اشیا کار می کند.

پل، state  استراتژی (و تا حدی آداپتور) ساختارهای بسیار مشابهی دارند. در واقع، همه این الگوها بر اساس ترکیب بندی هستند که کار را به اشیاء دیگر واگذار می کند. با این حال، همه آنها مشکلات مختلفی را حل می کنند. یک الگو فقط دستور العملی برای ساختار کد شما به روشی خاص نیست. همچنین می‌تواند مشکلی را که الگو حل می‌کند با توسعه‌دهندگان دیگر ارتباط برقرار کند 
